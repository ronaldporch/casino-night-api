#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('casino-night-api:server');
var http = require('http');
r = require('rethinkdb');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = require('socket.io')(server)

// Set up rethinkdb connection
var connection = null
r.connect({ host: 'localhost', port: 28015 }, function (err, conn) {
  if (err) throw err
  connection = conn
})

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

var tmi = require('tmi.js')

let options = {
  options: {
    debug: true
  },
  connection: {
    cluster: 'aws',
    reconnect: true
  },
  identity: {
    username: 'casinonightbot',
    password: 'password'
  },
  channels: ['dada5714']
}

let client = new tmi.client(options)
client.color('Blue')
client.connect()

let sendAllRecords = (socket, emit) => (err, cursor) => {
  if (err) throw err
  cursor.toArray((err, result) => {
    if (err) throw err
    socket.emit(emit, result)
  })
}

let sendChange = (socket, emit) => (err, cursor) => {
  if (err) throw err
  cursor.each((err, result) => {
    if (err) throw err
    socket.emit(emit, result)
  })
}

let messageSuccess = (socket, emit) => (err, result) => {
  if (err) throw err
  socket.emit(emit)
}

let readData = (socket, emit) => (err, result) => {
  if (err) throw err
  socket.emit(emit, result)
}

let readRecordFromArray = (socket, emit) => (err, cursor) => {
  if (err) throw err
  cursor.toArray((err, result) => {
    if (err) throw err
    let game = results[0]

    socket.emit(emit, result[0])
  })
}

intervals = []

let db = 'casinonight'
  users = r.db(db).table('users')
  games = r.db(db).table('games')

let decrementTime = function (id) {
  games.get(id)('timeLeft').eq(0).not().run(connection, (err, hasTimeLeft) => {
    if (err) throw err
    let options = { returnChanges: true }
    let update = (hasTimeLeft)
      ? { timeLeft: r.row('timeLeft').sub(1) }
      : { bettingOpen: false }
    games.get(id).update(update, options).run(connection, function (err, result) {
      if (err) throw err
      console.log(JSON.stringify(result, null, 1))
      if (!hasTimeLeft) {
        clearInterval(intervals[id])
        client.action('dada5714', `Betting Over! Let the games commence! FrankerZ`)
      }
    })
  })
}

io.on('connection', socket => {

  let thing = {
    players: ["Mario", "Bowser", "Samus"],
    timeLeft: 10,
    date: new Date(),
    bets: [],
    bettingOpen: true
  }

  let options = {
    returnChanges: true
  }

  games.insert(thing, options).run(connection, (err, result) => {
    if (err) return err
    currentBet = result.changes[0].new_val
    // Start new timer for this game
    intervals[currentBet.id] = setInterval(decrementTime, 1000, currentBet.id)
    games.get(currentBet.id).changes().run(connection, sendChange(socket, 'game.update'))
  })
  socket.on('game.latest.get', () => {
    games
      .orderBy(r.desc('date'))
      .limit(1).run(connection, (err, cursor) => {
        if (err) throw err
        cursor.toArray((err, result) => {
          if (err) throw err
          let game = result[0]
          games
            .get(game.id)
            .changes()
            .filter(r.row('new_val')('bets').count().gt(r.row('old_val')('bets').count()))
            .run(connection, sendChange(socket, 'game.latest.bets.update'))
          socket.emit('game.latest.send', game)
        })
      })
  })
  socket.on('user.get', user => {
    users.get(user.id).run(connection, readData(socket, 'user.send'))
    users.get(user.id).changes().run(connection, sendChange(socket, 'user.update'))
  })

  socket.on('game.latest.bet.send', bet => {
    let user = users.get(bet.bet.userId)
    user('money').ge(bet.bet.amount).run(connection, (err, hasTheCash) => {
      if (err) throw err
      if (hasTheCash) {
        user.update({money: r.row('money').sub(bet.bet.amount)}).run(connection, (err) => {
          games.get(bet.gameId).update({
            bets: r.row("bets").append(bet.bet)
          }).run(connection, messageSuccess(socket, 'bet.success'))
        })
      }
    })
  })
})

// Twitchbot specific stuff

currentBet = undefined

client.on('chat', (channel, user, message, self) => {
  if (message === '!help') {
    client.action('dada5714', `
!signup: Sign up for Casino Night to participate. You start off with 1000. \n
!bet [Player (No spaces)] [Amount]: Make a bet for a player. No Spaces for the Player Name. (!bet captainfalcon 50) \n
!help: Get list of commands.
    `)
  }
  else if (`#${user.username}` === channel && message.search('!newgame') === 0 && message.search('!newgame') !== -1) {
    let messageParse = message.split(' ')
    if (!isNaN(parseInt(messageParse[1]))
      && typeof parseInt(messageParse[1]) === 'number'
      && typeof messageParse[2] !== 'undefined'
      && typeof messageParse[3] !== 'undefined'
    ) {
      let time = parseInt(messageParse[1])
      messageParse.splice(0, 2)
      let g = {
        "bets": [ ],
        "bettingOpen": true,
        "date": new Date(),
        "timeLeft": time,
        "players": messageParse
      }
      let o = {
        returnChanges: true
      }
      games.insert(g, o).run(connection, function(err, game){
        if (err) throw err
        currentBet = game.changes[0].new_val
        intervals[currentBet.id] = setInterval(decrementTime, 1000, currentBet.id)
        client.action('dada5714', `New game starting! Participants: ${currentBet.players.join(', ')}. Type !signup if you aren't already a participant. Type !bet (character) (amount) to submit a bet.`)
      })
    }
  }
  else if (message.search('!signup') !== -1) {
    let newUser = {
      "email": "thing@thing.com",
      "money": 1000,
      "username": user['display-name']
    }
    let options = {
      returnChanges: true
    }
    users.insert(newUser, options).run(connection, (err, result) => {
      if (err) throw err
      let returnedUser = result.changes[0].new_val
      if (returnedUser) {
        client.whisper(user['display-name'], `${user['display-name']} Thanks for joining! We'll start you off with 1000 credits. Get to betting! (If you supplied your email, check it out.)`)
      }
    })
  }
  else if (message.search('!bet') !== -1) {
    var bet = {
      player: message.split(' ')[1],
      amount: parseInt(message.split(' ')[2])
    }
    if (isNaN(bet.amount) || typeof bet.amount !== 'number') {
      client.action('dada5714', `${user['display-name']} bet is not formatted currently. Please try again.`)
    } else {
      users.filter({ username: user['display-name'] }).run(connection, (err, cursor) => {
        if (err) throw err
        cursor.toArray((err, CNUser) => {
          if (err) throw err
          let existingUser = CNUser[0]
          if (existingUser) {
            if (existingUser.money >= bet.amount) {
              users.get(existingUser.id).update({money: r.row('money').sub(bet.amount)}, { returnChanges: true }).run(connection, (err, changes) => {
                bet.userId = existingUser.id
                games.get(currentBet.id).update({
                  bets: r.row("bets").append(bet)
                }).run(connection, err => {
                  if (err) throw err
                  client.whisper(user['display-name'], `You placed a bet of $${bet.amount} for ${bet.player}. You currently have $${changes.changes[0].new_val.money}`)
                })
              })
            } else {
              client.action('dada5714', `${user['display-name']} not enough money! Try winning a little more.`)
            }
          }
        })
      })
    }
  }
})
client.on('connected', function (address, port) {
    client.action('dada5714', `Casino Night Bot Activated. Welcome to Casino Night! Type !help for a list of commands.`)
  // let g = {
  //   "bets": [ ],
  //   "bettingOpen": true,
  //   "date": new Date(),
  //   "players": [
  //     "Mario",
  //     "Bowser",
  //     "Samus"
  //   ] ,
  //   "timeLeft": 120
  // }
  // let o = {
  //   returnChanges: true
  // }
  // games.insert(g, o).run(connection, function(err, game){
  //   if (err) throw err
  //   currentBet = game.changes[0].new_val
  //   intervals[currentBet.id] = setInterval(decrementTime, 1000, currentBet.id)
  //   client.action('dada5714', `New game starting! Participants: ${currentBet.players.join(', ')}. Type !signup if you aren't already a participant. Type !bet (character) (amount) to submit a bet.`)
  // })
})

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
